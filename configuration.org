#+AUTHOR: Seth Morabito
#+EMAIL:  web@loomcom.com
#+TITLE:  GNU Emacs Configuration File
#+DATE:   11 July 2019
#+OPTIONS: toc:1 ':t
#+STARTUP: showall

* Introduction

  This document contains my entire GNU Emacs configuration file in
  /"Literate Programming"/ style. Literate Programming strives to
  invert the normal programming paradigm; Instead of source code
  scattered with comments, Literate Programming encourages code to be
  written as a human readable document, in prose, with source code
  blocks embedded inside of it. The source code later interpreted,
  while the human readable prose is ignored.

  The magic here is provided by =org-babel=, which provides a method
  for extracting and evaluating Emacs Lisp expressions inside an
  =org-mode= file.

  The only line that needs to be in your =~/.emacs.d/init.el= file, then,
  is this:

  #+BEGIN_EXAMPLE
    (org-babel-load-file "~/.emacs.d/configuration.org")
  #+END_EXAMPLE

* Basic Setup

** Identity

   I begin by explicitly identifying myself and setting my full name
   and email address.

   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Seth Morabito")
     (setq user-mail-address "web@loomcom.com")
   #+END_SRC

** Reducing Clutter

   Next, I like to immediately reduce what I consider to be visual
   clutter. Your milage may vary, but for me this means turning off
   startup messages, the splash screen, scroll bars, tool bar,
   tooltips, and the menu.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
     (setq inhibit-splash-screen t)
     (display-graphic-p)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (menu-bar-mode -1)
   #+END_SRC

* Behavior

** Tidying Up the Working Directory

   Emacs, by default, keeps backup files in the current working
   directory. I much prefer to keep all backup files together in one
   place. This will put them all into the directory
   =~/.emacs.d/backups/=, creating the directory if it does not exist.

   #+BEGIN_SRC emacs-lisp
     (if (not (file-exists-p "~/.emacs.d/backups/"))
         (make-directory "~/.emacs.d/backups/" t))
     (setq backup-directory-alist
           '(("." . "~/.emacs.d/backups/")))
     (setq auto-save-file-name-transforms
           '((".*" "~/.emacs.d/backups/" t)))
     (setq backup-by-copying t)
     (setq auto-save-default t)
   #+END_SRC

   Next, these settings control how many backup versions to keep, and
   specify that older versions should be silently deleted (don't warn
   me).

   #+BEGIN_SRC emacs-lisp
     (setq kept-old-versions 2)
     (setq kept-new-versions 5)
     (setq delete-old-versions t)
   #+END_SRC

   And finally, I completely disable lockfiles, which I don't need,
   and which only cause trouble.

   #+BEGIN_SRC emacs-lisp
     (setq create-lockfiles nil)
   #+END_SRC

** Scrolling

   =scroll-step= controls the number of lines that the window will
   scroll automatically when the cursor moves off the screen. By default,
   it will jump you so that the cursor is centered (vertically) after
   scrolling. I really don't like this behavior, so I set it to =1= so
   the window will only move by a single line.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-step 1)
   #+END_SRC

   Next, setting =scroll-conservatively= to a very large number will
   further prevent automatic centering. The value =10,000= comes from
   a suggestion on the [[https://www.emacswiki.org/emacs/SmoothScrolling][Emacs Wiki]].

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 10000)
   #+END_SRC

** Indentation

   I always prefer 4 spaces for indents.

   #+BEGIN_SRC emacs-lisp
     (setq-default c-basic-offset 4)
     (setq-default sh-basic-offset 4)
     (setq-default tab-width 4)
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   And next, I want to fix how multi-line initialization in C-like
   languages is handled (for example, when initializing an array or a
   struct). By default, elements after the =brace-list-intro=
   character get lined up directly below it, like this:

   #+BEGIN_EXAMPLE
   int array[3] = {
                   0,
                   1,
                   2,
   };
   #+END_EXAMPLE

   By setting the correct value for =c-set-offset 'brace-list-intro=,
   I can get what I consider to be a much better offset that
   looks like this:

   #+BEGIN_EXAMPLE
   int array[3] = {
       0,
       1,
       2,
   };
   #+END_EXAMPLE

   Here's the setting:

   #+BEGIN_SRC emacs-lisp
    (c-set-offset 'brace-list-intro '+)
   #+END_SRC

** Whitespace Cleanup

   At one point, I used a save hook that automatically deleted
   trailing whitespace. While noble, this was a bad idea,
   especially when working in shared projects! It could lead
   to unwanted changes making their way into version control.
   So, instead, these settings will highlight trailing whitespace
   so that I can clean it up on a case-by-case basis.

   #+BEGIN_SRC emacs-lisp
     (require 'whitespace)
     (setq-default show-trailing-whitespace t)
   #+END_SRC

   ... however, there is one exception! The minibuffer
   and the help buffer are not editable, and shouldn't
   have trailing whitespace called out.

   #+BEGIN_SRC emacs-lisp
     (defun no-trailing-whitespace ()
       (setq show-trailing-whitespace nil))

     (add-hook 'minibuffer-setup-hook
               'no-trailing-whitespace)

     (add-hook 'help-mode-hook
               'no-trailing-whitespace)
   #+END_SRC

** Tramp

   /Tramp/ is a useful mode that allows editing files remotely.

   The first thing I like to do is set the default connection method.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-default-method "ssh")
   #+END_SRC

   Then, I up some default values to make editing large directories
   happy.

   #+BEGIN_EXAMPLE
     (setq max-lisp-eval-depth 4000)   ; default is 400
     (setq max-specpdl-size 5000)      ; default is 1000
   #+END_EXAMPLE

** Saving the Desktop

   When these are uncommented, the current emacs "desktop" (basically,
   the state of the frames and all the buffers) will be saved and
   reloaded automatically between sessions. I honestly cannot decide
   whether I want this or not, hence, it is commented out right now.

   #+BEGIN_SRC emacs-lisp
   ; (defvar desktop-dirname user-emacs-directory)
   ; (desktop-save-mode 1)
   #+END_SRC

** Recent Files

   Keep a list of recently opened files

   #+BEGIN_SRC emacs-lisp
     (recentf-mode 1)
     (setq-default recent-save-file "~/.emacs.d/recentf")
   #+END_SRC

** Exec Path

   If certain directories exist, they should be added to the
   exec-path.

   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p "/usr/local/bin")
       (setq exec-path (append exec-path '("/usr/local/bin")))
       (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin")))

     (when (file-exists-p "/Library/TeX/texbin")
       (setq exec-path (append exec-path '("/Library/TeX/texbin")))
       (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin")))
   #+END_SRC

** Encryption

   Enable integration between Emacs and GPG.

   #+BEGIN_SRC emacs-lisp
     (setenv "GPG_AGENT_INFO" nil)
     (require 'epa-file)
     (require 'password-cache)
     (setq epg-pgp-program "gpg")
     (setq password-cache-expiry (* 15 60))
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
     (setq epa-pinentry-mode 'loopback)
   #+END_SRC

** Window Navigation

   I frequently split my Emacs windows both horizontally and
   vertically. Navigation between windows with =C-x o= is tedious, so
   I have mandated the following keys for navigation:

   - =C-<left>= :: Navigate to the window to the left of the current
                   window.
   - =C-<right>= :: Navigate to the window to the right of the current
                    window.
   - =C-<up>= :: Navigate to the window above the current window.
   - =C-<down>= :: Navigate to the window below the current window.

   This is harder than it sounds, for a number of reasons.

   First, by default, if you try to navigate to a window that doesn't
   exist (for example, if you're in the left-most window and try to
   move left again), Emacs will throw an error and complain. To work
   around this, I define a function called =quiet-windmove= that will
   take a direction to move, and swallow errors.

   #+BEGIN_SRC emacs-lisp
    (defun quiet-windmove (direction)
      "Catch all errors and silently return nil.
    ,* DIRECTION is a symbol, 'left, 'right, 'up, or 'down."
      (condition-case nil
          (cond ((eq direction 'left)
                 (windmove-left))
                ((eq direction 'right)
                 (windmove-right))
                ((eq direction 'up)
                 (windmove-up))
                ((eq direction 'down)
                 (windmove-down)))
        (error nil)))
   #+END_SRC

   Next, for convenience, I define a bunch of short functions
   to move in the cardinal directions.

   #+BEGIN_SRC emacs-lisp
    (defun quiet-windmove-left ()
      "Navigate to the window immediately to the left the current one."
      (interactive) (quiet-windmove 'left))

    (defun quiet-windmove-right ()
      "Navigate to the window immediately to the right the current one."
      (interactive) (quiet-windmove 'right))

    (defun quiet-windmove-up ()
      "Navigate to the window immediately above the current one."
      (interactive) (quiet-windmove 'up))

    (defun quiet-windmove-down ()
      "Navigate to the window immediately below the current one."
      (interactive) (quiet-windmove 'down))

   #+END_SRC

   And then, finally, bind the keys to the functions to do the
   movement.

   Again, there's a problem. MacOS, Linux GTK, Linux terminal, and
   Windows all may (or may not) provide different keycodes for
   the arrow keys. Oh boy!

*** MacOS

    #+BEGIN_SRC emacs-lisp
    (global-set-key (read-kbd-macro "M-[ 5 D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ 5 C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ 5 A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ 5 B") 'quiet-windmove-down)
    (global-set-key (read-kbd-macro "M-[ D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ B") 'quiet-windmove-down)
    #+END_SRC

*** Linux Terminal

    #+BEGIN_SRC emacs-lisp
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 B") 'quiet-windmove-down)

    #+END_SRC

*** Linux GTK

    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-<left>")  'quiet-windmove-left)
    (global-set-key (kbd "C-<right>") 'quiet-windmove-right)
    (global-set-key (kbd "C-<up>")    'quiet-windmove-up)
    (global-set-key (kbd "C-<down>")  'quiet-windmove-down)

    #+END_SRC

** Other Key Bindings

*** Shortcut for "Goto Line"

    #+BEGIN_SRC emacs-lisp
    (global-set-key "\C-xl" 'goto-line)

    #+END_SRC

** Miscellaneous Settings

   Turn off the infernal bell, both visual and audible.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

   Enable the =upcase-region= function. I still have no idea
   why this is disabled by default.

   #+BEGIN_SRC emacs-lisp
     (put 'upcase-region 'disabled nil)
   #+END_SRC

   Whenever we visit a buffer that has no active edits, but the file
   has changed on disk, automatically reload it.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC

   I'm really not smart sometimes, so I need emacs to warn me when I
   try to quit it.

   #+BEGIN_SRC emacs-lisp
     (setq confirm-kill-emacs 'yes-or-no-p)
   #+END_SRC

   Remote X11 seems to have problems with delete for me (mostly
   XQuartz, I believe), so I force erase to be backspace.

   #+BEGIN_SRC emacs-lisp
     (when (eq window-system 'x)
       (normal-erase-is-backspace-mode 1))
   #+END_SRC

* Appearance

** Theme

   Load the default theme.

   #+BEGIN_SRC emacs-lisp
    (load-theme 'wombat t)
   #+END_SRC

** Default Face

   I have become enamored of the /"Input Mono"/ family of fonts.

   #+BEGIN_SRC emacs-lisp
     (when (member "Input Mono" (font-family-list))
       (set-face-attribute 'default nil
                           :family "Input Mono"
                           :weight 'light
                           :height 120))
   #+END_SRC

** Window Frame

   By default, the Emacs frame (what you or I would call a window)
   title is *user@host*. I much prefer the frame title to show the
   actual name of the currently selected buffer.

   #+BEGIN_SRC emacs-lisp
    (setq-default frame-title-format "%b")
    (setq frame-title-format "%b")
   #+END_SRC

** Face Tweaks

   To make org blocks stand out a bit, I prefer to set some custom
   colors. These may need to be tweaked whenever using a different
   theme.

   #+BEGIN_SRC emacs-lisp
    (set-face-attribute 'org-block nil
                        :background "#000001"
                        :foreground "#ffffff")
   #+END_SRC

   Then I customize a bit more about org-mode.

   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'org-block-begin-line nil
                         :inherit 'org-meta-line
                         :foreground "gray35")
     (set-face-attribute 'org-block-end-line nil
                         :inherit 'org-meta-line
                         :foreground "gray35")
     (set-face-attribute 'org-document-title nil
                         :foreground "#de935f"
                         :weight 'bold
                         :height 1.0)
     (set-face-attribute 'org-level-1 nil
                         :inherit 'outline-1
                         :underline t
                         :weight 'bold
                         :height 1.6)
   #+END_SRC


** Changing Font Size on the Fly

   By default, you can increase or decrease the font face size in a
   single window with =C-x C-+= or =C-x C--=, respectively.  This is
   fine, but it applies to the /current window only/. I like to map
   =C-+= and =C--= to functions that will change the height of the
   default face in ALL windows.

   First, I create a base function to do the change by a certain
   amount in a certain direction.

   #+BEGIN_SRC emacs-lisp
    (defun change-face-size (dir-func &optional delta)
      "Increase or decrease font size in all frames and windows.

    ,* DIR-FUNC is a direction function (embiggen-default-face) or
      (ensmallen-default-face)
    ,* DELTA is an amount to increase.  By default, the value is 10."
      (progn
        (set-face-attribute
         'default nil :height
         (funcall dir-func (face-attribute 'default :height) delta))))

   #+END_SRC

   Then, I create two little helper functions to bump the size up or
   down.

   #+BEGIN_SRC emacs-lisp
     (defun embiggen-default-face (&optional delta)
       "Increase the default font.

     ,* DELTA is the amount (in point units) to increase the font size.
       If not specified, the dfault is 10."
       (interactive)
       (let ((incr (or delta 10)))
         (change-face-size '+ incr)))

     (defun ensmallen-default-face (&optional delta)
       "Decrease the default font.

     ,* DELTA is the amount (in point units) to decrease the font size.
       If not specified, the default is 10."
       (interactive)
       (let ((incr (or delta 10)))
         (change-face-size '- incr)))
   #+END_SRC

   And, finally, bind those functions to the right keys.

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-+")  'embiggen-default-face)
    (global-set-key (kbd "C--")  'ensmallen-default-face)
   #+END_SRC

** Shell Colors

   Turn on ANSI colors in the shell.

   #+BEGIN_SRC emacs-lisp
     (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
   #+END_SRC

** Line Numbers

   I like to see line numbers in the gutter at all times.

   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode)
   #+END_SRC

   Furthermore, I like to see /(Line,Column)/ displayed in the modeline.

   #+BEGIN_SRC emacs-lisp
     (setq line-number-mode t)
     (setq column-number-mode t)
   #+END_SRC

** Show the Time

   I like having the day, date, and time displayed in my
   modeline. (Note that it's pointless to display seconds here, since
   the modeline does not automatically update every second, for
   efficiency purposes)

   #+BEGIN_SRC emacs-lisp
     (setq display-time-day-and-date t)
     (display-time-mode 1)
   #+END_SRC

** Line Wrapping

   By default, if a frame has been split horizontally,
   partial windows will not wrap.

   #+BEGIN_SRC emacs-lisp
     (setq truncate-partial-width-windows nil)
   #+END_SRC

** Parentheses

   Whenever the cursor is on a paren, highlight the matching paren.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
   #+END_SRC

** Mac OS X Specific Tweaks

   GNU Emacs running on recent versions of MacOS in particular exhibit
   some pretty ugly UI elements. Further, I don't like having to use
   the /Option/ key for /Meta/, so I switch things around on the
   keyboard. Note, though, that this block is only evaluated when the
   windowing system is ='ns=, so this won't do anything at all on
   Linux.

   #+BEGIN_SRC emacs-lisp
     (when (eq window-system 'ns)
       (add-to-list 'frameset-filter-alist
                    '(ns-transparent-titlebar . :never))
       (add-to-list 'frameset-filter-alist
                    '(ns-appearance . :never))
       (setq mac-option-modifier 'super
             mac-command-modifier 'meta
             mac-function-modifier 'hyper
             mac-right-option-modifier 'super))
   #+END_SRC

* Packages

** Basic Setup

   Before we begin, add some special folders to the load-path. We'll
   need these for packages that are /not/ installed from ELPA and MELPA.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/lisp")
     (add-to-list 'load-path "~/.emacs.d/local")
   #+END_SRC

   Next, require the =package= mode and set up URLs to the package
   archives.

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup t)
     (setq package-archives '(("org" . "https://orgmode.org/elpa/")
                              ("gnu" . "https://elpa.loomcom.com/")
                              ("melpa" . "https://melpa.org/packages/")))
   #+END_SRC

   Then, actually initialize things.

   #+BEGIN_SRC emacs-lisp
     (package-initialize)
   #+END_SRC

   And then, if the =use-package= package is not installed, install it
   immediately.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (require 'use-package)
   #+END_SRC

** Auto Update

   #+BEGIN_SRC emacs-lisp
     (use-package auto-package-update
       :ensure t
       :config
       (setq auto-package-update-delete-old-versions t)
       (setq auto-package-update-hide-results t)
       (auto-package-update-maybe))
   #+END_SRC


** Slime

   Our first package is a little bit of an exception. I don't load
   Slime as a package. Instead, I prefer to load it from Quicklisp, if
   and only if Quicklisp is installed.

   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p (expand-file-name "~/quicklisp/slime-helper.el"))
       (load (expand-file-name "~/quicklisp/slime-helper.el"))
       (defvar inferior-lisp-program "sbcl"))
   #+END_SRC

** Email

   The second package is also a bit of an exception. I read email in
   emacs using =mu4e=, which is installed locally. Since this
   configuration is shared between computers, and not all of my
   computers have =mu4e= installed, this configuration will only be
   applied if =mu4e= is successfully loaded.

   Note, too, that I load mail configuration from the file


   =~/.emacs.d/local/mail-and-news.el=.  This is specifically so that
   I don't have to check my sensitive account information into a
   public source code repository.

   #+BEGIN_SRC emacs-lisp
          (when (and (require 'mu4e nil 'noerror)
                     (file-exists-p
                      (expand-file-name
                       "~/.emacs.d/local/mail-and-news.el")))
            (load "mail-and-news.el")
            (add-hook 'mu4e-view-mode-hook 'visual-line-mode))
   #+END_SRC

** Org Mode

   Next is =org-mode=, which I use constantly, day in and day out.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :pin org
       :ensure org-plus-contrib
       :config
       (require 'cl)
       (require 'ox-latex)
       (setq org-agenda-tags-column -100)
       (setq org-deadline-warning-days 14)
       (setq org-table-shrunk-column-indicator ""))
   #+END_SRC

   I have a lot of custom configuration for =org-mode=.

*** Org-Babel Language Integration

    I want to be able to support C, Emacs Lisp, and GraphViz blocks in org-babel.

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages '((C . t)
                                   (emacs-lisp . t)
                                   (dot . t)))
    #+END_SRC

*** Adding YouTube Links

    This block adds a link handler for YouTube links in =org-mode=
    buffers.

    #+BEGIN_SRC emacs-lisp
      (defvar youtube-iframe-format
        (concat "<iframe width=\"440\""
                " height=\"335\""
                " src=\"https://www.youtube.com/embed/%s\""
                " frameborder=\"0\""
                " allowfullscreen>%s</iframe>"))

      (org-link-set-parameters
       "youtube"
       :follow (lambda (id)
                 (browse-url
                  (concat "https://www.youtube.com/embed/" id)))
       :export (lambda (path desc backend)
                 (cl-case backend
                   (html (format youtube-iframe-format
                                 path (or desc "")))
                   (latex (format "\href{%s}{%s}"
                                  path (or desc "video"))))))
    #+END_SRC

*** HTML Export Tweaks

    I prefer to insert periods after section numbers when exporting
    =org-mode= files to HTML. This tweak enables that.

    #+BEGIN_SRC emacs-lisp
      (defun my-html-filter-headline-yesdot (text backend info)
        "Ensure dots in headlines.
      ,* TEXT is the text being exported.
      ,* BACKEND is the backend (e.g. 'html).
      ,* INFO is ignored."
        (when (org-export-derived-backend-p backend 'html)
          (save-match-data
            (when (let ((case-fold-search t))
                    (string-match
                     (rx (group "<span class=\"section-number-" (+ (char digit)) "\">"
                                (+ (char digit ".")))
                         (group "</span>"))
                     text))
              (replace-match "\\1.\\2"
                             t nil text)))))

      (eval-after-load 'ox
        '(progn
           (add-to-list 'org-export-filter-headline-functions
                        'my-html-filter-headline-yesdot)))
    #+END_SRC

*** Display Options

    I turn on Pretty Entities, which allows Emacs, in graphics mode,
    to render unicode symbols, math symbols, and so on. I also set
    a custom ellipsis character that will be shown when sections or
    blocks are collapsed.

    #+BEGIN_SRC emacs-lisp
      (setq org-pretty-entities t
            org-ellipsis "▼")
    #+END_SRC

*** Org Agenda Setup

    I make frequent use of =org-agenda= to track my time.

    I add a quick and easy way to get into =org-agenda= from any
    =org-mode= buffer by pressing =C-c a=.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook
                (lambda ()
                  (local-set-key
                   (kbd "C-c a") 'org-agenda)))
    #+END_SRC

    Next, I add a custom =org-agenda= command to show the next three
    weeks.

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
            '(("N" "Next Three Weeks" agenda ""
               ((org-agenda-span 21)
                (org-agenda-start-on-weekday 0)))))
    #+END_SRC

    Then, I define some faces and use them for deadlines
    in =org-agenda=.

    #+BEGIN_SRC emacs-lisp
      (defface deadline-soon-face
        '((t (:foreground "#ff0000"
                          :weight bold
                          :slant italic
                          :underline t))) t)
      (defface deadline-near-face
        '((t (:foreground "#ffa500"
                          :weight bold
                          :slant italic))) t)
      (defface deadline-distant-face
        '((t (:foreground "#ffff00"
                          :weight bold
                          :slant italic))) t)

      (setq org-agenda-deadline-faces
            '((0.75 . deadline-soon-face)
              (0.5  . deadline-near-face)
              (0.25 . deadline-distant-face)
              (0.0  . deadline-distant-face)))
    #+END_SRC

    And finally, I set my =org-todo-keywords= so that I can manage my
    TODO states the way I like to.

    The syntax =@= following a definition indicates that a state needs
    a note with a timestamp, while a =!= indicates that it needs only
    a timestamp.

    The =(a/b)= syntax indicates that action =a= should happen on
    entry, and =b= should happen on exit. For example, =WAIT(w@/!)=
    means that the workflow state =WAIT= can be accessed by the short
    form =w=, and that a timestamp with a note should be recorded on
    entry, but only a timestamp should be recorded on exit.

    The vertical separator =|= separates keywords that need further
    actions from those that are end states.

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            '((sequence
               "TODO(t)"
               "NEXT(n)"
               "WAIT(w@/!)"
               "|"
               "DONE(d@)"
               "CANCELED(c@)")))
    #+END_SRC

    And here, as a last step, I can load any additional optional
    =org-agenda= setup I want. This is largely because I use this
    configuration for both my home and my work computers, and my
    home and work workflows are different.

    #+BEGIN_SRC emacs-lisp
      (when (file-exists-p
             (expand-file-name
              "~/.emacs.d/local/org-agenda-setup.el"))
        (load "org-agenda-setup.el"))
    #+END_SRC

*** Export Settings

    This adds support the \LaTeX{} class =koma-article= on \LaTeX{}
    export.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-latex-classes
                   '("koma-article"
                     "\\documentclass{scrartcl}"
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    #+END_SRC

*** Org Agenda

   Org Agenda is a great way of tracking time and progress on various
   projects and repeatable tasks. It's built into org-mode.

   This first bit defines what files to consult when building an
   agenda (I keep all of my agenda files under owncloud for syncing
   purposes).

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-files
           (file-expand-wildcards "~/ownCloud/Notes/*.org"))
   #+END_SRC

   And next, I define where to keep archived agenda items. By default,
   these would go into a file called
   =<original-file-name>.org_archive=, but I don't like that
   behavior. Instead, I put them into a subdirectory and don't add the
   =.org_archive= extension, preferring just to keep =.org= instead.

   #+BEGIN_SRC emacs-lisp
     (setq org-archive-location
           (concat "~/ownCloud/Notes/Archive/%s::"))
   #+END_SRC

** Email Alerts

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e-alert
       :defer t
       :after mu4e
       :config
       (setq mu4e-alert-interesting-mail-query
             "flag:unread AND NOT flag:trashed AND NOT maildir/Spam")
       (mu4e-alert-enable-mode-line-display))
   #+END_SRC

** Scrollbar Replacement

   #+BEGIN_SRC emacs-lisp
     (use-package sml-modeline
       :ensure t
       :init
       (sml-modeline-mode))
   #+END_SRC

** Org Bullets

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :ensure t
       :commands (org-bullets-mode)
       :init
       (add-hook
        'org-mode-hook
        (lambda () (org-bullets-mode 1))))
   #+END_SRC

** Tab Bar

   #+BEGIN_SRC emacs-lisp
     (use-package tabbar
       :config (tabbar-mode t)
       :ensure t)
   #+END_SRC

** Support for Encrypted Authinfo

   #+BEGIN_SRC emacs-lisp
     (use-package auth-source
       :ensure t
       :config
       (setq auth-sources '("~/.authinfo.gpg")))
   #+END_SRC

** Microsoft Exchange Integration

   At work (but not at home), I connect to an Exchange server
   and integrate my meetings with Emacs. Once again, a local
   configuration allows me to have sensitive information like
   Exchange URLs separate from my main Emacs config.

   #+BEGIN_SRC emacs-lisp
     (use-package excorporate
       :load-path "lisp/excorporate"
       :ensure url-http-ntlm
       :ensure fsm
       :after org
       :config
       (when
           (file-exists-p
            (expand-file-name
             "~/.emacs.d/local/excorporate-setup.el"))
         (load "excorporate-setup.el")))
   #+END_SRC

** Ledger Mode

   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :ensure t)
   #+END_SRC

** GraphViz (dot) Mode

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure t)
   #+END_SRC

** Git Integration

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package git-gutter
       :ensure t
       :init
       (global-git-gutter-mode +1))
   #+END_SRC

** Snippets

   Snippets build in support for typing a few keys, pressing tab, and
   getting a complete template inserted into your buffer. I use these
   heavily. In addition to the built-in snippets that come from the
   =yasnippet-snippets= package, I have some custom snippets defined
   in the =snippets= directory.

   #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :config
      (add-to-list 'auto-mode-alist '("~/.emacs.d/snippets"))
      (yas-global-mode))

    (use-package yasnippet-snippets
      :ensure t
      :defer t
      :after yasnippet
      :config (yasnippet-snippets-initialize))
   #+END_SRC

** Development Support

   I really like paredit, especially for Lisp, but I don't like the
   default key bindings, so I tweak them heavily. Primarily, the
   problem is that I use =C-<left>= and =C-<right>= to navigate
   between windows in Emacs, so I don't want to use them for
   Paredit. Instead, I remap these to =C-S-<left>= and =C-S-<right>=,
   respectively. One issue is that =<left>= and =<right>= may differ
   depending on the platform I'm on, so there are several alternate
   definitions here to make sure it works on all platforms.  What a
   pain.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t
       :defer t
       :init
       (autoload 'enable-paredit-mode "paredit" "Structural editing of Lisp")
       (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
       (add-hook 'ielm-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
       (add-hook 'scheme-mode-hook #'enable-paredit-mode)
       :config
       (define-key paredit-mode-map (kbd "C-<left>") nil)
       (define-key paredit-mode-map (kbd "C-<right>") nil)
       (define-key paredit-mode-map (kbd "C-S-<left>")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (kbd "C-S-<right>")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 5 D")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 5 C")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "M-[ 1 ; 6 d")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "M-[ 1 ; 6 c")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 1 ; 5 D")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 1 ; 5 C")
         'paredit-forward-slurp-sexp))

   #+END_SRC

   Flycheck enables syntax checking for many different languages.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :hook (prog-mode . flycheck-mode))
   #+END_SRC

   Company enables autocompletion.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :hook (prog-mode . company-mode)
       :config
       (setq company-idle-delay 1)
       (setq company-tooltip-align-annotations t)
       (setq company-minimum-prefix-length 1))
   #+END_SRC

   CEDET provides a lot of nice support for C and C++ development.

   #+BEGIN_SRC emacs-lisp
     (use-package cedet
       :ensure t
       :init
       (semantic-mode 1)
       (global-semantic-decoration-mode 1)
       (global-semantic-stickyfunc-mode 1)
       (global-semantic-idle-summary-mode 1)
       (global-semantic-idle-local-symbol-highlight-mode 1)
       (global-semantic-highlight-func-mode 1)
       :bind (:map semantic-mode-map
                   ("C-c , >" . semantic-ia-fast-jump)))
   #+END_SRC

   I have a few custom directories that I always want Flycheck to
   search, so I set those here.

   #+BEGIN_SRC emacs-lisp
     (setq flycheck-clang-include-path
           (list
            (expand-file-name "~/Projects/simh/")
            (expand-file-name "~/Projects/simh/3B2/")))
   #+END_SRC

   And finally, LSP adds advanced features for languages and tools
   that have Language Server Protocol support.

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :ensure t
       :config (require 'lsp-clients))

     (use-package lsp-ui
       :ensure t)
   #+END_SRC

** Web Development

   Web Mode offers a very nice integrated experience for editing HTML,
   JavaScript, and CSS.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :defer t)
   #+END_SRC

   I almost never use PHP, but it's nice to have when you really,
   really need it.

   #+BEGIN_SRC emacs-lisp
     (use-package php-mode
       :ensure t
       :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :ensure t)
   #+END_SRC

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :ensure t
       :defer t)
   #+END_SRC

** Rust

   Rust's Cargo configuration files use TOML.

   #+BEGIN_SRC emacs-lisp
     (use-package toml-mode
       :ensure t)
   #+END_SRC

   Next, configure Rust Mode. Note that the hooks are set up in the
   =init:= block intentionally. There is a dependency load order
   problem that prevents them from being =hook:= calls.

   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :ensure t
       :defer t
       :bind (("C-c TAB" . rust-format-buffer))
       :init
       (add-hook 'rust-mode-hook #'flycheck-mode)
       :hook
       (prog-mode . electric-pair-mode)
       (rust-mode . lsp)
       :config
       (define-key rust-mode-map (kbd "TAB")
         #'company-indent-or-complete-common)
       (use-package racer
         :ensure t
         :defer t)
       (use-package flycheck
         :ensure t))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package cargo
       :ensure t
       :hook (rust-mode . cargo-minor-mode)
       :after rust-mode
       :config
       (setenv "PATH" (concat (getenv "PATH") ":~/.cargo/bin"))
       (setq exec-path (append exec-path '("~/.cargo/bin"))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-rust
       :ensure t
       :after rust
       :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
   #+END_SRC

** Emacs Helm

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :bind (("C-x C-f" . helm-find-files)
              ("C-x f" . helm-recentf)
              ("C-x b" . helm-buffers-list)
              ("M-x" . helm-M-x))
       :config
       (setq helm-candidate-number-limit 50
             helm-fuzzy-matching t
             helm-split-window-inside-p t
             helm-move-to-line-cycle-in-source t
             helm-scroll-amount 8
             helm-echo-input-in-header-line t
             helm-autoresize-max-height 0
             helm-autoresize-min-height 20
             helm-ff-file-name-history-use-recentf t)
       (helm-mode 1))
   #+END_SRC

* Loom Communications Homepage

  I keep my homepage entirely in =org-mode=. Configuration is stored
  mostly in the separate file =loomcom.el=. There is a little bit of
  extra stuff here, however.

  First, I have a few helper functions for publishing.

** Publish the site locally

   =org-publish= has one fatal flaw: It opens a /lot/ of buffers, and
   if =global-git-gutter-mode= or =magit-file-mode= are enabled (as
   they usually are), Emacs grinds to a halt. So, in order to publish
   efficiently, those modes /must/ be turned off. We can turn them
   back on after publishing is complete.

   #+BEGIN_SRC emacs-lisp
    (defun loomcom-publish-local ()
      "Publish my website, but do not push to the server."
      (interactive)
      (remove-hook 'find-file-hooks 'vc-find-file-hook)
      (magit-file-mode -1)
      (global-git-gutter-mode -1)
      (org-publish-all)
      (global-git-gutter-mode +1)
      (magit-file-mode +1)
      (add-hook 'find-file-hooks 'vc-find-file-hook))
   #+END_SRC

** Push published files to the server

   Once files have been published to local disk, they need to be
   rsynced to the server.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom-rsync-www ()
       "Rsync my working directory to my public web directory."
       (interactive)
       (let ((publish-dir (expand-file-name "~/Projects/loomcom/www/"))
             (remote-dir "loomcom.com:/var/www/loomcom/"))
         (when (file-exists-p publish-dir)
           (shell-command
            (format
             "rsync -avz --delete --delete-after %s %s"
             publish-dir
             remote-dir)))))
   #+END_SRC

** Do a complete publishing cycle

   Finally, here's a function that will publish my webpage from start
   to finish.

   #+BEGIN_SRC emacs-lisp
    (defun loomcom-publish ()
      "Publish my website."
      (interactive)
      (loomcom-publish-local)
      (loomcom-rsync-www))
   #+END_SRC

** Miscellaneous Tweaks

   #+BEGIN_SRC emacs-lisp
    (defun loomcom/fix-inline-images ()
      "Redisplay inline images."
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))

    (add-hook 'org-babel-after-execute-hook
              'loomcom/fix-inline-images)
   #+END_SRC

** Load the main config

   #+BEGIN_SRC emacs-lisp
    (load "loomcom.el")
   #+END_SRC

* Frame Placement

  Define a helper function that will center the frame on its display.

  #+BEGIN_SRC emacs-lisp
    (defun center-frame-in-display ()
      (interactive)
      (let* ((col-width (/ (frame-pixel-width) (frame-width)))
         (row-height (/ (frame-pixel-height) (frame-height)))
         (half-width (* (/ (frame-width) 2) col-width))
         (half-height (* (/ (frame-height) 2) row-height))
         (center-x (/ (display-pixel-width) 2))
         (center-y (/ (display-pixel-height) 2)))
    (set-frame-position
     (selected-frame)
     (- center-x half-width)
     (- center-y half-height))))
  #+END_SRC

  Then, resize and center the frame.

  #+BEGIN_SRC emacs-lisp
    (set-frame-width (selected-frame) 98)
    (set-frame-height (selected-frame) 56)
    (center-frame-in-display)
  #+END_SRC
