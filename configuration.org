#+AUTHOR: Seth Morabito
#+EMAIL:  web@loomcom.com
#+TITLE:  GNU Emacs Configuration File
#+DATE:   11 July 2019
#+OPTIONS: toc:1 ':t
#+STARTUP: showall

* Introduction

  This document contains my entire GNU Emacs configuration file in
  /"Literate Programming"/ style. Literate Programming strives to
  invert the normal programming paradigm; Instead of source code
  scattered with comments, Literate Programming encourages code to be
  written as a human readable document, in prose, with source code
  blocks embedded inside of it. The source code later interpreted,
  while the human readable prose is ignored.

  The magic here is provided by =org-babel=, which provides a method
  for extracting and evaluating Emacs Lisp expressions inside an
  =org-mode= file.

  There is one more thing: Emacs comes with a built-in version of Org
  Mode that is out of date and obsolete. Because of that, I provide my
  own checkout of Org Mode as a submodule. The first two lines of my
  =init.el= file then add this submodule to the load path. This is
  required to use the submodule version of org mode. My =init.el=
  looks like this:

  #+BEGIN_EXAMPLE
    (add-to-list 'load-path "~/.emacs.d/org-mode/lisp")
    (add-to-list 'load-path "~/.emacs.d/org-mode/contrib/lisp")

    (org-babel-load-file "~/.emacs.d/configuration.org")
  #+END_EXAMPLE

  To finish the bootstrap, all you need to do is:

  #+BEGIN_EXAMPLE
  $ cd ~/.emacs.d
  $ git submodule init
  $ cd ~/.emacs.d/org-mode
  $ make
  #+END_EXAMPLE

* Basic Setup

** Identity

   I begin by explicitly identifying myself and setting my full name
   and email address.

   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Seth Morabito")
     (setq user-mail-address "web@loomcom.com")
   #+END_SRC

** Reducing Clutter

   Next, I like to immediately reduce what I consider to be visual
   clutter. Your milage may vary, but for me this means turning off
   startup messages, the splash screen, scroll bars, tool bar,
   tooltips, and the menu.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
     (setq inhibit-splash-screen t)
     (display-graphic-p)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (menu-bar-mode -1)
   #+END_SRC

* Behavior

** Tidying Up the Working Directory

   Emacs, by default, keeps backup files in the current working
   directory. I much prefer to keep all backup files together in one
   place. This will put them all into the directory
   =~/.emacs.d/backups/=, creating the directory if it does not exist.

   #+BEGIN_SRC emacs-lisp
     (if (not (file-exists-p "~/.emacs.d/backups/"))
         (make-directory "~/.emacs.d/backups/" t))
     (setq backup-directory-alist
           '(("." . "~/.emacs.d/backups/")))
     (setq auto-save-file-name-transforms
           '((".*" "~/.emacs.d/backups/" t)))
     (setq backup-by-copying t)
     (setq auto-save-default t)
   #+END_SRC

   Next, these settings control how many backup versions to keep, and
   specify that older versions should be silently deleted (don't warn
   me).

   #+BEGIN_SRC emacs-lisp
     (setq kept-old-versions 2)
     (setq kept-new-versions 5)
     (setq delete-old-versions t)
   #+END_SRC

   And finally, I completely disable lockfiles, which I don't need,
   and which only cause trouble.

   #+BEGIN_SRC emacs-lisp
     (setq create-lockfiles nil)
   #+END_SRC

** Scrolling

   =scroll-step= controls the number of lines that the window will
   scroll automatically when the cursor moves off the screen. By default,
   it will jump you so that the cursor is centered (vertically) after
   scrolling. I really don't like this behavior, so I set it to =1= so
   the window will only move by a single line.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-step 1)
   #+END_SRC

   Next, setting =scroll-conservatively= to a very large number will
   further prevent automatic centering. The value =10,000= comes from
   a suggestion on the [[https://www.emacswiki.org/emacs/SmoothScrolling][Emacs Wiki]].

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 10000)
   #+END_SRC

** Indentation

   I always prefer 4 spaces for indents.

   #+BEGIN_SRC emacs-lisp
     (setq-default c-basic-offset 4)
     (setq-default sh-basic-offset 4)
     (setq-default tab-width 4)
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   And next, I want to fix how multi-line initialization in C-like
   languages is handled (for example, when initializing an array or a
   struct). By default, elements after the =brace-list-intro=
   character get lined up directly below it, like this:

   #+BEGIN_EXAMPLE
   int array[3] = {
                   0,
                   1,
                   2,
   };
   #+END_EXAMPLE

   By setting the correct value for =c-set-offset 'brace-list-intro=,
   I can get what I consider to be a much better offset that
   looks like this:

   #+BEGIN_EXAMPLE
   int array[3] = {
       0,
       1,
       2,
   };
   #+END_EXAMPLE

   Here's the setting:

   #+BEGIN_SRC emacs-lisp
    (c-set-offset 'brace-list-intro '+)
   #+END_SRC

** Tramp

   /Tramp/ is a useful mode that allows editing files remotely.

   The first thing I like to do is set the default connection method.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-default-method "ssh")
   #+END_SRC

   Then, I up some default values to make editing large directories
   happy.

   #+BEGIN_EXAMPLE
     (setq max-lisp-eval-depth 4000)   ; default is 400
     (setq max-specpdl-size 5000)      ; default is 1000
   #+END_EXAMPLE

** Saving the Desktop

   When these are uncommented, the current emacs "desktop" (basically,
   the state of the frames and all the buffers) will be saved and
   reloaded automatically between sessions. I honestly cannot decide
   whether I want this or not, hence, it is commented out right now.

   #+BEGIN_SRC emacs-lisp
   ; (defvar desktop-dirname user-emacs-directory)
   ; (desktop-save-mode 1)
   #+END_SRC

** Recent Files

   Keep a list of recently opened files

   #+BEGIN_SRC emacs-lisp
     (recentf-mode 1)
     (setq-default recent-save-file "~/.emacs.d/recentf")
   #+END_SRC

** Exec Path

   If certain directories exist, they should be added to the
   exec-path.

   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p "/usr/local/bin")
       (setq exec-path (append exec-path '("/usr/local/bin")))
       (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin")))

     (when (file-exists-p "/Library/TeX/texbin")
       (setq exec-path (append exec-path '("/Library/TeX/texbin")))
       (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin")))
   #+END_SRC

** Encryption

   Enable integration between Emacs and GPG.

   #+BEGIN_SRC emacs-lisp
     (setenv "GPG_AGENT_INFO" nil)
     (require 'epa-file)
     (require 'password-cache)
     (setq epg-pgp-program "gpg")
     (setq password-cache-expiry (* 15 60))
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
     (setq epa-pinentry-mode 'loopback)
   #+END_SRC

** Window Navigation

   I frequently split my Emacs windows both horizontally and
   vertically. Navigation between windows with =C-x o= is tedious, so
   I have mandated the following keys for navigation:

   - =C-<left>= :: Navigate to the window to the left of the current
                   window.
   - =C-<right>= :: Navigate to the window to the right of the current
                    window.
   - =C-<up>= :: Navigate to the window above the current window.
   - =C-<down>= :: Navigate to the window below the current window.

   This is harder than it sounds, for a number of reasons.

   First, by default, if you try to navigate to a window that doesn't
   exist (for example, if you're in the left-most window and try to
   move left again), Emacs will throw an error and complain. To work
   around this, I define a function called =quiet-windmove= that will
   take a direction to move, and swallow errors.

   #+BEGIN_SRC emacs-lisp
    (defun quiet-windmove (direction)
      "Catch all errors and silently return nil.
    ,* DIRECTION is a symbol, 'left, 'right, 'up, or 'down."
      (condition-case nil
          (cond ((eq direction 'left)
                 (windmove-left))
                ((eq direction 'right)
                 (windmove-right))
                ((eq direction 'up)
                 (windmove-up))
                ((eq direction 'down)
                 (windmove-down)))
        (error nil)))
   #+END_SRC

   Next, for convenience, I define a bunch of short functions
   to move in the cardinal directions.

   #+BEGIN_SRC emacs-lisp
    (defun quiet-windmove-left ()
      "Navigate to the window immediately to the left the current one."
      (interactive) (quiet-windmove 'left))

    (defun quiet-windmove-right ()
      "Navigate to the window immediately to the right the current one."
      (interactive) (quiet-windmove 'right))

    (defun quiet-windmove-up ()
      "Navigate to the window immediately above the current one."
      (interactive) (quiet-windmove 'up))

    (defun quiet-windmove-down ()
      "Navigate to the window immediately below the current one."
      (interactive) (quiet-windmove 'down))
   #+END_SRC

   And then, finally, bind the keys to the functions to do the
   movement.

   Again, there's a problem. MacOS, Linux GTK, Linux terminal, and
   Windows all may (or may not) provide different keycodes for
   the arrow keys. Oh boy!

*** MacOS

    #+BEGIN_SRC emacs-lisp
    (global-set-key (read-kbd-macro "M-[ 5 D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ 5 C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ 5 A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ 5 B") 'quiet-windmove-down)
    (global-set-key (read-kbd-macro "M-[ D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ B") 'quiet-windmove-down)
    #+END_SRC

*** Linux Terminal

    #+BEGIN_SRC emacs-lisp
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 D") 'quiet-windmove-left)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 C") 'quiet-windmove-right)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 A") 'quiet-windmove-up)
    (global-set-key (read-kbd-macro "M-[ 1 ; 5 B") 'quiet-windmove-down)

    #+END_SRC

*** Linux GTK

    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-<left>")  'quiet-windmove-left)
    (global-set-key (kbd "C-<right>") 'quiet-windmove-right)
    (global-set-key (kbd "C-<up>")    'quiet-windmove-up)
    (global-set-key (kbd "C-<down>")  'quiet-windmove-down)

    #+END_SRC

** Other Key Bindings

*** Shortcut for "Goto Line"

    #+BEGIN_SRC emacs-lisp
    (global-set-key "\C-xl" 'goto-line)

    #+END_SRC

** Miscellaneous Settings

   Turn off the infernal bell, both visual and audible.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

   Enable the =upcase-region= function. I still have no idea
   why this is disabled by default.

   #+BEGIN_SRC emacs-lisp
     (put 'upcase-region 'disabled nil)
   #+END_SRC

   Whenever we visit a buffer that has no active edits, but the file
   has changed on disk, automatically reload it.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC

   I'm really not smart sometimes, so I need emacs to warn me when I
   try to quit it.

   #+BEGIN_SRC emacs-lisp
     (setq confirm-kill-emacs 'yes-or-no-p)
   #+END_SRC

   Remote X11 seems to have problems with delete for me (mostly
   XQuartz, I believe), so I force erase to be backspace.

   #+BEGIN_SRC emacs-lisp
     (when (eq window-system 'x)
       (normal-erase-is-backspace-mode 1))
   #+END_SRC

   When functions are redefined with =defadvice=, a warning is
   emitted. This is annoying, so I disable these warnings.

   #+BEGIN_SRC emacs-lisp
     (setq ad-redefinition-action 'accept)
   #+END_SRC

   Tell Python mode to use Python 3

   #+BEGIN_SRC emacs-lisp
     (setq flycheck-python-pycompile-executable "python3")
     (setq flycheck-python-flake8-executable "python3")
     (setq flycheck-python-pylint-executable "python3")
     (setq python-shell-interpreter "python3")
   #+END_SRC


* Appearance

** Default Face

   I have become enamored of the /"Input Mono"/ family of fonts.

   #+BEGIN_SRC emacs-lisp
     (when (member "Input Mono" (font-family-list))
       (set-face-attribute 'default nil
                           :family "Input Mono"
                           :weight 'light
                           :height 120))
   #+END_SRC

** Emacs 27

   Beginning in Emacs 27, a new attribute, =:extend=, was added to faces.
   It determines whether the background of a face will extend to the right
   margin or not. It defaults to =nil=, but I prefer it to be set for some
   things.

   #+BEGIN_SRC emacs-lisp
     (when (>= emacs-major-version 27)
       (set-face-attribute 'org-block nil :extend t)
       (set-face-attribute 'org-block-begin-line nil :extend t)
       (set-face-attribute 'org-block-end-line nil :extend t))
   #+End_SRC

** Window Frame

   By default, the Emacs frame (what you or I would call a window)
   title is *user@host*. I much prefer the frame title to show the
   actual name of the currently selected buffer.

   #+BEGIN_SRC emacs-lisp
    (setq-default frame-title-format "%b")
    (setq frame-title-format "%b")
   #+END_SRC

** Changing Font Size on the Fly

   By default, you can increase or decrease the font face size in a
   single window with =C-x C-+= or =C-x C--=, respectively.  This is
   fine, but it applies to the /current window only/. I like to map
   =C-+= and =C--= to functions that will change the height of the
   default face in ALL windows.

   First, I create a base function to do the change by a certain
   amount in a certain direction.

   #+BEGIN_SRC emacs-lisp
    (defun change-face-size (dir-func &optional delta)
      "Increase or decrease font size in all frames and windows.

    ,* DIR-FUNC is a direction function (embiggen-default-face) or
      (ensmallen-default-face)
    ,* DELTA is an amount to increase.  By default, the value is 10."
      (progn
        (set-face-attribute
         'default nil :height
         (funcall dir-func (face-attribute 'default :height) delta))))
   #+END_SRC

   Then, I create two little helper functions to bump the size up or
   down.

   #+BEGIN_SRC emacs-lisp
     (defun embiggen-default-face (&optional delta)
       "Increase the default font.

     ,* DELTA is the amount (in point units) to increase the font size.
       If not specified, the dfault is 10."
       (interactive)
       (let ((incr (or delta 10)))
         (change-face-size '+ incr)))

     (defun ensmallen-default-face (&optional delta)
       "Decrease the default font.

     ,* DELTA is the amount (in point units) to decrease the font size.
       If not specified, the default is 10."
       (interactive)
       (let ((incr (or delta 10)))
         (change-face-size '- incr)))
   #+END_SRC

   And, finally, bind those functions to the right keys.

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-+")  'embiggen-default-face)
    (global-set-key (kbd "C--")  'ensmallen-default-face)
   #+END_SRC

** Shell Colors

   Turn on ANSI colors in the shell.

   #+BEGIN_SRC emacs-lisp
     (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
   #+END_SRC

** Line Numbers

   I like to see line numbers in the gutter at all times.

   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode)
   #+END_SRC

   Furthermore, I like to see /(Line,Column)/ displayed in the modeline.

   #+BEGIN_SRC emacs-lisp
     (setq line-number-mode t)
     (setq column-number-mode t)
   #+END_SRC

** Show the Time

   I like having the day, date, and time displayed in my
   modeline. (Note that it's pointless to display seconds here, since
   the modeline does not automatically update every second, for
   efficiency purposes)

   #+BEGIN_SRC emacs-lisp
     (setq display-time-day-and-date t)
     (display-time-mode 1)
   #+END_SRC

** Line Wrapping

   By default, if a frame has been split horizontally,
   partial windows will not wrap.

   #+BEGIN_SRC emacs-lisp
     (setq truncate-partial-width-windows nil)
   #+END_SRC

** Parentheses

   Whenever the cursor is on a paren, highlight the matching paren.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
   #+END_SRC

** Mac OS X Specific Tweaks

   GNU Emacs running on recent versions of MacOS in particular exhibit
   some pretty ugly UI elements. Further, I don't like having to use
   the /Option/ key for /Meta/, so I switch things around on the
   keyboard. Note, though, that this block is only evaluated when the
   windowing system is ='ns=, so this won't do anything at all on
   Linux.

   #+BEGIN_SRC emacs-lisp
     (when (eq window-system 'ns)
       (add-to-list 'frameset-filter-alist
                    '(ns-transparent-titlebar . :never))
       (add-to-list 'frameset-filter-alist
                    '(ns-appearance . :never))
       (setq mac-option-modifier 'super
             mac-command-modifier 'meta
             mac-function-modifier 'hyper
             mac-right-option-modifier 'super))
   #+END_SRC

* Packages

** Basic Setup

   Before we begin, add some special folders to the load-path. We'll
   need these for packages that are /not/ installed from ELPA and MELPA.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/lisp")
     (add-to-list 'load-path "~/.emacs.d/local")
   #+END_SRC

   Next, require the =package= mode and set up URLs to the package
   archives.

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup t)
     (setq package-archives '(("org" . "https://orgmode.org/elpa/")
                              ("gnu" . "https://elpa.gnu.org/packages/")
                              ("melpa" . "https://melpa.org/packages/")))
   #+END_SRC

   Then, actually initialize things.

   #+BEGIN_SRC emacs-lisp
     (package-initialize)
   #+END_SRC

   And then, if the =use-package= package is not installed, install it
   immediately.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (require 'use-package)
   #+END_SRC

** Auto Update

   #+BEGIN_SRC emacs-lisp
     (use-package auto-package-update
       :ensure t
       :config
       (setq auto-package-update-delete-old-versions t)
       (setq auto-package-update-hide-results t)
       (auto-package-update-maybe))
   #+END_SRC

** Slime

   Our first package is a little bit of an exception. I don't load
   Slime as a package. Instead, I prefer to load it from Quicklisp, if
   and only if Quicklisp is installed.

   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p (expand-file-name "~/quicklisp/slime-helper.el"))
       (load (expand-file-name "~/quicklisp/slime-helper.el"))
       (setq inferior-lisp-program "sbcl"))
   #+END_SRC

** Email

   The second package is also a bit of an exception. I read email in
   emacs using =mu4e=, which is installed locally. Since this
   configuration is shared between computers, and not all of my
   computers have =mu4e= installed, this configuration will only be
   applied if =mu4e= is successfully loaded.

   First, we attempt to require =mu4e=.

   #+BEGIN_SRC emacs-lisp
     (when (require 'mu4e nil 'noerror)
   #+END_SRC

   If that succeeded, it's time to configure things.

   The first bit of code defines a replacement for the standard =html2text=
   function. It's slightly nicer.

   #+BEGIN_SRC emacs-lisp
       (defun shr-html2text ()
         "Replacement for standard html2text using shr."
         (interactive)
         (let ((dom (libxml-parse-html-region (point-min) (point-max)))
               (shr-width fill-column)
               (shr-inhibit-images t)
               (shr-bullet " "))
           (erase-buffer)
           (shr-insert-document dom)
           (goto-char (point-min))))

       (setq mu4e-html2text-command 'shr-html2text)
   #+END_SRC

   Then, I want to configure how =shr= handles color in HTML
   email.

   #+BEGIN_SRC emacs-lisp
     (require 'mu4e-contrib)
     (setq mu4e-html2text-command 'mu4e-shr2text)
     ;; (setq shr-color-visible-luminance-min 60)
     (setq shr-color-visible-luminance-min 20)
     (setq shr-color-visible-distance-min 5)
     ;; (setq shr-use-colors t)
     (advice-add #'shr-colorize-region :around
                 (defun shr-no-colourise-region (&rest ignore)))
   #+END_SRC

   Next, I set up a bunch of basic =mu4e= settings. This tells it
   where to look for mail, and how to send mail via SMTP.

   Authentication is all handled through an =~/.authinfo.gpg= file,
   which is encrypted, and holds username and password information for
   the SMTP server.

   One note: The =mu4e-get-mail-command= is set to =/bin/true= here
   because I simply want it to be a no-op. Mail retrieval is all
   handled with =offlineimap=, so there's really nothing to get.

   #+BEGIN_SRC emacs-lisp
       (setq
        mu4e-maildir (expand-file-name "~/Maildir/")
        mail-user-agent 'mu4e-user-agent
        mu4e-drafts-folder "/Drafts"
        mu4e-sent-folder "/Sent"
        mu4e-refile-folder "/Archive"
	mu4e-trash-folder "/Trash"
        mu4e-get-mail-command "/bin/true"
        mu4e-update-interval 60
        user-mail-address "web@loomcom.com"
        user-full-name "Seth J. Morabito"
        message-send-mail-function 'smtpmail-send-it
        smtpmail-smtp-server "smtp.fastmail.com"
        smtpmail-default-smtp-server "smtp.fastmail.com"
        smtpmail-auth-credentials '(("smtp.fastmail.com" 587 nil nil))
        smtpmail-smtp-service 587)
   #+END_SRC

   I also like to enable =visual-line-mode= whenever I'm reading
   messages.

   #+BEGIN_SRC emacs-lisp
       (add-hook 'mu4e-view-mode-hook 'visual-line-mode)
   #+END_SRC

   And finally, I add some useful =mu4e= bookmarks.

   #+BEGIN_SRC emacs-lisp
       (add-to-list 'mu4e-bookmarks
                    (make-mu4e-bookmark
                     :name "Flagged Messages"
                     :query "flag:flagged"
                     :key ?f))

       (add-to-list 'mu4e-bookmarks
                    (make-mu4e-bookmark
                     :name "Unread (Non-List)"
                     :query "flag:unread
     AND NOT flag:trashed
     AND NOT flag:list"
                     :key ?l))

       (add-to-list 'mu4e-bookmarks
                    (make-mu4e-bookmark
                     :name "Today (Non-List)"
                     :query "date:today..now
     AND NOT flag:trashed
     AND NOT flag:list AND NOT maildir:/Archive"
                     :key ?T))

       (add-to-list 'mu4e-bookmarks
                    (make-mu4e-bookmark
                     :name "This Week (Non-List)"
                     :query "date:1w..now
     AND NOT flag:trashed
     AND NOT flag:list
     AND NOT maildir:/Archive"
                     :key ?W)))
   #+END_SRC

** GNUS

   I don't read Usenet very much any more, but it's nice to reminisce.
   /Eternal September/ is a free Usenet provider that has a feed of
   text-only articles. No binaries. I like it that way.

   #+BEGIN_SRC emacs-lisp
     (setq gnus-select-method '(nntp "news.eternal-september.org"))
     (setq gnus-extra-headers '(To Newsgroup))
     (setq nnmail-extra-headers gnus-extra-headers)
     (setq gnus-summary-line-format "%U%R%z %4i %([%4L: %-25,25f]%) %I%s\n")
     (setq gnus-summary-same-subject "-||-")
   #+END_SRC

** Org Mode

   Next is =org-mode=, which I use constantly, day in and day out.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :load-path "~/.emacs.d/org-mode/lisp"
       :ensure t
       :config
       (require 'cl)
       (require 'ox-latex)
       (require 'org-drill)
       (setq org-agenda-tags-column -100)
       (setq org-deadline-warning-days 14)
       (setq org-table-shrunk-column-indicator "")
       (setq org-adapt-indentation t))
   #+END_SRC

   #+RESULTS:
   : t

   I have a lot of custom configuration for =org-mode=.

*** Org Capture

    To capture new notes, I configure Org Capture with a quick
    key binding of =C-c c=.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c c") 'org-capture)
    #+END_SRC

*** Org-Babel Language Integration

    I want to be able to support C, Emacs Lisp, and GraphViz blocks in org-babel.

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages '((C . t)
                                   (emacs-lisp . t)
                                   (dot . t)))
    #+END_SRC

*** Adding YouTube Links

    This block adds a link handler for YouTube links in =org-mode=
    buffers.

    #+BEGIN_SRC emacs-lisp
      (defvar youtube-iframe-format
        (concat "<iframe width=\"440\""
                " height=\"335\""
                " src=\"https://www.youtube.com/embed/%s\""
                " frameborder=\"0\""
                " allowfullscreen>%s</iframe>"))

      (org-link-set-parameters
       "youtube"
       :follow (lambda (id)
                 (browse-url
                  (concat "https://www.youtube.com/embed/" id)))
       :export (lambda (path desc backend)
                 (cl-case backend
                   (html (format youtube-iframe-format
                                 path (or desc "")))
                   (latex (format "\href{%s}{%s}"
                                  path (or desc "video"))))))
    #+END_SRC

*** HTML Export Tweaks

    I prefer to insert periods after section numbers when exporting
    =org-mode= files to HTML. This tweak enables that.

    #+BEGIN_SRC emacs-lisp
      (defun my-html-filter-headline-yesdot (text backend info)
        "Ensure dots in headlines.
      ,* TEXT is the text being exported.
      ,* BACKEND is the backend (e.g. 'html).
      ,* INFO is ignored."
        (when (org-export-derived-backend-p backend 'html)
          (save-match-data
            (when (let ((case-fold-search t))
                    (string-match
                     (rx (group "<span class=\"section-number-" (+ (char digit)) "\">"
                                (+ (char digit ".")))
                         (group "</span>"))
                     text))
              (replace-match "\\1.\\2"
                             t nil text)))))

      (eval-after-load 'ox
        '(progn
           (add-to-list 'org-export-filter-headline-functions
                        'my-html-filter-headline-yesdot)))
    #+END_SRC

*** Display Options

    I turn on Pretty Entities, which allows Emacs, in graphics mode,
    to render unicode symbols, math symbols, and so on. I also set
    a custom ellipsis character that will be shown when sections or
    blocks are collapsed.

    #+BEGIN_SRC emacs-lisp
      (setq org-pretty-entities t
            org-ellipsis "▼")
    #+END_SRC

    I also really enjoy hiding emphasis markers.

    #+BEGIN_SRC emacs-lisp
      (setq org-hide-emphasis-markers t)
    #+END_SRC

*** Export Settings

    This adds support the LaTeX class =koma-article= on LaTeX export.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-latex-classes
                   '("koma-article"
                     "\\documentclass{scrartcl}"
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    #+END_SRC

*** Org Agenda

   Org Agenda is a great way of tracking time and progress on various
   projects and repeatable tasks. It's built into org-mode.

    I add a quick and easy way to get into =org-agenda= from any
    =org-mode= buffer by pressing =C-c a=.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook
                (lambda ()
                  (local-set-key
                   (kbd "C-c a") 'org-agenda)))
    #+END_SRC

    Next, I add a custom =org-agenda= command to show the next three
    weeks.

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
            '(("N" "Next Three Weeks" agenda ""
               ((org-agenda-span 21)
                (org-agenda-start-on-weekday 0)))))
    #+END_SRC

    Then, I define some faces and use them for deadlines in
    =org-agenda=.

    #+BEGIN_SRC emacs-lisp
      (defface deadline-soon-face
        '((t (:foreground "#ff0000"
                          :weight bold
                          :slant italic
                          :underline t))) t)
      (defface deadline-near-face
        '((t (:foreground "#ffa500"
                          :weight bold
                          :slant italic))) t)
      (defface deadline-distant-face
        '((t (:foreground "#ffff00"
                          :weight bold
                          :slant italic))) t)

      (setq org-agenda-deadline-faces
            '((0.75 . deadline-soon-face)
              (0.5  . deadline-near-face)
              (0.25 . deadline-distant-face)
              (0.0  . deadline-distant-face)))
    #+END_SRC

    Then I set my =org-todo-keywords= so that I can manage my workflow
    states the way I like to.

    The syntax =@= following a definition indicates that a state needs
    a note with a timestamp, while a =!= indicates that it needs only
    a timestamp.

    The =(a/b)= syntax indicates that action =a= should happen on
    entry, and =b= should happen on exit. For example, =WAIT(w@/!)=
    means that the workflow state =WAIT= can be accessed by the short
    form =w=, and that a timestamp with a note should be recorded on
    entry, but only a timestamp should be recorded on exit.

    The vertical separator =|= separates keywords that need further
    actions from those that are end states.

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            '((sequence
               "TODO(t)"
               "NEXT(n)"
               "WAIT(w/!)"
               "|"
               "DONE(d)"
               "CANCELED(c)")))
    #+END_SRC

   And finally, I set some file locations. This is a bit convoluted
   because I use Agenda both for work and for home. At work, I keep a
   file called =~/.org-agenda-setup.el= that contains my agenda files
   and archive location information. At home, I just use what's baked
   into this file.

   Also note that I like to keep archived Agenda items in a separate
   directory, rather than the default behavior of renaming them to
   =<original-file-name>.org_archive=.

   #+BEGIN_SRC emacs-lisp
     (if (file-exists-p "~/.org-agenda-setup.el")
         (load "~/.org-agenda-setup.el")
       (progn
         (global-set-key (kbd "C-c o")
                         (lambda ()
                           (interactive)
                           (find-file "~/Nextcloud/Notes/tasks.org")))
         (setq org-agenda-files (file-expand-wildcards "~/Nextcloud/Notes/*.org")
               org-archive-location (concat "~/Nextcloud/Notes/Archive/%s::")
               org-default-notes-file "~/Nextcloud/Notes/tasks.org")))
   #+END_SRC

** Themes

   Note that after installing these, you should run =M-x all-the-icons-install-fonts=.

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :ensure t)

     (use-package doom-modeline
       :ensure t
       :hook
       (after-init . doom-modeline-mode))

     (use-package doom-themes
       :ensure t
       :defer t
       :init
       (load-theme 'doom-moonlight t))
   #+END_SRC

** Email Alerts

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e-alert
       :defer t
       :after mu4e
       :config
       (setq mu4e-alert-interesting-mail-query
             "flag:unread AND NOT flag:trashed AND NOT maildir/Spam")
       (mu4e-alert-enable-mode-line-display))
   #+END_SRC

** Scrollbar Replacement

   #+BEGIN_SRC emacs-lisp
     (use-package sml-modeline
       :ensure t
       :init
       (sml-modeline-mode))
   #+END_SRC

** Org Bullets

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :ensure t
       :commands (org-bullets-mode)
       :config
       (setq org-bullets-bullet-list
           '("●" "♦" "►" "•" "▸"))
       :init
       (add-hook
        'org-mode-hook
        (lambda () (org-bullets-mode 1))))
   #+END_SRC

** IRC

   I like to use ERC for talking on IRC. This configuration was completely
   stolen from =u/rmberYou= on Reddit, [[https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/][who shared it in the r/emacs community]].

   #+BEGIN_SRC emacs-lisp
     (use-package erc
       :ensure t
       :custom
       (erc-autojoin-channels-alist
        '(("irc.freenode.net" "#emacs" "#org-mode" "##3b2")))
       (erc-autojoin-timing 'ident)
       (erc-fill-function 'erc-fill-static)
       (erc-fill-static-center 22)
       (erc-hide-list '("JOIN" "PART" "QUIT"))
       (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
       (erc-lurker-threshold-time 43200)
       (erc-prompt-for-nickserv-password nil)
       (erc-server-reconnect-attempts 5)
       (erc-server-reconnect-timeout 3)
       (erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                                  "324" "329" "332" "333" "353" "477"))
       :config
       (add-to-list 'erc-modules 'notifications)
       (add-to-list 'erc-modules 'spelling)
       (erc-services-mode 1)
       (erc-update-modules))

     (use-package erc-hl-nicks
       :ensure t
       :after erc)

     (use-package erc-image
       :ensure t
       :after erc)

     (defun my/erc-start-or-switch ()
       "Connects to ERC, or switch to last active buffer."
       (interactive)
       (if (get-buffer "irc.freenode.net:6667")
           (erc-track-switch-buffer 1)
         (when (y-or-n-p "Start ERC? ")
           (erc :server "irc.freenode.net" :port 6667 :nick "Twylo"))))

     (defun my/erc-notify (nickname message)
       "Displays a notification message for ERC."
       (let* ((channel (buffer-name))
              (nick (erc-hl-nicks-trim-irc-nick nickname))
              (title (if (string-match-p (concat "^" nickname) channel)
                         nick
                       (concat nick " (" channel ")")))
              (msg (s-trim (s-collapse-whitespace message))))
         (alert (concat nick ": " msg) :title title)))

     (defun my/erc-count-users ()
       "Displays the number of users connected on the current channel."
       (interactive)
       (if (get-buffer "irc.freenode.net:6667")
           (let ((channel (erc-default-target)))
             (if (and channel (erc-channel-p channel))
                 (message "%d users are online on %s"
                          (hash-table-count erc-channel-users)
                          channel)
               (user-error "The current buffer is not a channel")))
         (user-error "You must first start ERC")))

     (defun my/erc-preprocess (string)
       "Avoids channel flooding."
       (setq str
             (string-trim
              (replace-regexp-in-string "\n+" " " str))))
   #+END_SRC


** Support for Encrypted Authinfo

   #+BEGIN_SRC emacs-lisp
     (use-package auth-source
       :ensure t
       :config
       (setq auth-sources '("~/.authinfo.gpg")))
   #+END_SRC

** Ledger Mode

   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :ensure t)
   #+END_SRC

** GraphViz (dot) Mode

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure t)
   #+END_SRC

** YAML Mode (for docker, etc.)

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC


** Git Integration

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package git-gutter
       :ensure t
       :init
       (global-git-gutter-mode +1))
   #+END_SRC

** YAML

   YAML mode is useful for editing Docker files.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC


** Snippets

   Snippets build in support for typing a few keys, pressing tab, and
   getting a complete template inserted into your buffer. I use these
   heavily. In addition to the built-in snippets that come from the
   =yasnippet-snippets= package, I have some custom snippets defined
   in the =snippets= directory.

   #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :config
      (add-to-list 'auto-mode-alist '("~/.emacs.d/snippets"))
      (yas-global-mode))

    (use-package yasnippet-snippets
      :ensure t
      :defer t
      :after yasnippet
      :config (yasnippet-snippets-initialize))
   #+END_SRC

** Development Support

   I really like paredit, especially for Lisp, but I don't like the
   default key bindings, so I tweak them heavily. Primarily, the
   problem is that I use =C-<left>= and =C-<right>= to navigate
   between windows in Emacs, so I don't want to use them for
   Paredit. Instead, I remap these to =C-S-<left>= and =C-S-<right>=,
   respectively. One issue is that =<left>= and =<right>= may differ
   depending on the platform I'm on, so there are several alternate
   definitions here to make sure it works on all platforms.  What a
   pain.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t
       :defer t
       :init
       (autoload 'enable-paredit-mode "paredit" "Structural editing of Lisp")
       (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
       (add-hook 'ielm-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-mode-hook #'enable-paredit-mode)
       (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
       (add-hook 'scheme-mode-hook #'enable-paredit-mode)
       :config
       (define-key paredit-mode-map (kbd "C-<left>") nil)
       (define-key paredit-mode-map (kbd "C-<right>") nil)
       (define-key paredit-mode-map (kbd "C-S-<left>")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (kbd "C-S-<right>")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 5 D")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 5 C")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "M-[ 1 ; 6 d")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "M-[ 1 ; 6 c")
         'paredit-forward-slurp-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 1 ; 5 D")
         'paredit-forward-barf-sexp)
       (define-key paredit-mode-map (read-kbd-macro "S-M-[ 1 ; 5 C")
         'paredit-forward-slurp-sexp))

   #+END_SRC

   Flycheck enables syntax checking for many different languages.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :hook (prog-mode . flycheck-mode))
   #+END_SRC

   Company enables autocompletion.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :hook (prog-mode . company-mode)
       :config
       (setq company-idle-delay 2000)
       (setq company-tooltip-align-annotations t)
       (setq company-minimum-prefix-length 1))
   #+END_SRC

   CEDET provides a lot of nice support for C and C++ development.

   #+BEGIN_SRC emacs-lisp
     (use-package cedet
       :ensure t
       :bind (:map semantic-mode-map
                   ("C-c , >" . semantic-ia-fast-jump)))
   #+END_SRC

   I have a few custom directories that I always want Flycheck to
   search, so I set those here.

   #+BEGIN_SRC emacs-lisp
     (setq flycheck-clang-include-path
           (list
            (expand-file-name "~/Projects/simh/")
            (expand-file-name "~/Projects/simh/3B2/")
            (expand-file-name "~/Projects/emsdk/fastcomp/emscripten/system/include")))

     (setq flycheck-gcc-include-path flycheck-clang-include-path)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package eglot
       :ensure t
       :hook ((python-mode java-mode bash-mode rust-mode) . eglot-ensure))
   #+END_SRC

** Web Development

   Web Mode offers a very nice integrated experience for editing HTML,
   JavaScript, and CSS.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :defer t)
   #+END_SRC

   I almost never use PHP, but it's nice to have when you really,
   really need it.

   #+BEGIN_SRC emacs-lisp
     (use-package php-mode
       :ensure t
       :defer t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package typescript-mode
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :ensure t)
   #+END_SRC

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode
       :ensure t
       :defer t)
   #+END_SRC

** Rust

   Rust's Cargo configuration files use TOML.

   #+BEGIN_SRC emacs-lisp
     (use-package toml-mode
       :ensure t)
   #+END_SRC

   Next, configure Rust Mode. Note that the hooks are set up in the
   =init:= block intentionally. There is a dependency load order
   problem that prevents them from being =hook:= calls.

   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :ensure t
       :defer t
       :bind (("C-c TAB" . rust-format-buffer))
       :init
       (add-hook 'rust-mode-hook #'flycheck-mode)
       (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
       :hook
       (rust-mode . lsp)
       :config
       (define-key rust-mode-map (kbd "TAB")
         #'company-indent-or-complete-common)
       (use-package racer
         :ensure t
         :defer t)
       (use-package flycheck
         :ensure t))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package cargo
       :ensure t
       :hook (rust-mode . cargo-minor-mode)
       :after rust-mode
       :config
       (setenv "PATH" (concat (getenv "PATH") ":~/.cargo/bin"))
       (setq exec-path (append exec-path '("~/.cargo/bin"))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-rust
       :ensure t
       :after rust
       :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
   #+END_SRC

** Emacs Helm

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :bind (("C-x C-f" . helm-find-files)
              ("C-x f" . helm-recentf)
              ("C-x b" . helm-buffers-list)
              ("M-x" . helm-M-x))
       :config
       (setq helm-candidate-number-limit 50
             helm-fuzzy-matching t
             helm-split-window-inside-p t
             helm-move-to-line-cycle-in-source t
             helm-scroll-amount 8
             helm-echo-input-in-header-line t
             helm-autoresize-max-height 0
             helm-autoresize-min-height 20
             helm-ff-file-name-history-use-recentf t)
       (helm-mode 1))
   #+END_SRC

* Webpage Publishing

  I keep my main homepage ([[https://loomcom.com/][https://loomcom.com/]]) entirely in
  =org-mode=. This section details how =org-publish= is used to
  transform a mass of Org files into a website.

** Basic Setup

   First I define a few paths and a pointer to the header file, for
   conveninience.

   #+BEGIN_SRC emacs-lisp
     (setq loomcom-project-dir "~/Projects/loomcom/")
     (setq loomcom-org-dir (concat loomcom-project-dir "org/"))
     (setq loomcom-www-dir (concat loomcom-project-dir "www/"))
     (setq loomcom-blog-org-dir (concat loomcom-org-dir "blog/"))
     (setq loomcom-blog-www-dir (concat loomcom-www-dir "blog/"))
     (setq loomcom-header-file
           (concat loomcom-project-dir "org/header.html"))
     (setq loomcom-posts-per-page 12)
   #+END_SRC

   Next, I define some additional tags to be used in headers and
   footers.

   #+BEGIN_SRC emacs-lisp
     (setq loomcom-head
           (concat
            "<meta name=\"twitter:site\" content=\"@twylo\" />\n"
            "<meta name=\"twitter:creator\" content=\"@twylo\" />\n"
            "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n"
            "<link rel=\"icon\" type=\"image/png\" href=\"/images/icon/favicon-32x32.png\" />\n"
            "<link rel=\"apple-touch-icon-precomposed\" href=\"/images/icon/apple-touch-icon.png\" />\n"
            "<link rel=\"stylesheet\" type=\"text/css\" href=\"/res/faces.css\">\n"
            "<link rel=\"stylesheet\" type=\"text/css\" href=\"/res/style.css\">\n"))

     (setq loomcom-footer
           (concat
            "<div id=\"footer\">\n"
            "<p>Proudly published with "
            "<a href=\"https://www.gnu.org/software/emacs/\">Emacs</a> and "
            "<a href=\"https://orgmode.org/\">Org Mode</a>"
            "</div>"))
   #+END_SRC

   Now, it's on to the helper functions.

** Helper Function: Publishing The Site Locally

   =org-publish= has one fatal flaw: It opens a /lot/ of buffers, and
   if =global-git-gutter-mode= or =magit-file-mode= are enabled (as
   they usually are), Emacs grinds to a halt. So, in order to publish
   efficiently, those modes /must/ be turned off. We can turn them
   back on after publishing is complete.

   #+BEGIN_SRC emacs-lisp
    (defun loomcom-publish-local ()
      "Publish my website, but do not push to the server."
      (interactive)
      (remove-hook 'find-file-hooks 'vc-find-file-hook)
      (magit-file-mode -1)
      (global-git-gutter-mode -1)
      (org-publish-all)
      (global-git-gutter-mode +1)
      (magit-file-mode +1)
      (add-hook 'find-file-hooks 'vc-find-file-hook))
   #+END_SRC

** Helper Function: Pushing Published Files to the Server

   Once files have been published to local disk, they need to be
   rsynced to the server.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom-rsync-www ()
       "Rsync my working directory to my public web directory."
       (interactive)
       (let ((publish-dir loomcom-www-dir)
             (remote-dir "neon.loomcom.com:/var/www/loomcom/"))
         (when (file-exists-p publish-dir)
           (shell-command
            (format
             "rsync -avz --delete --delete-after %s %s"
             publish-dir
             remote-dir)))))
   #+END_SRC

** Helper Function: Do a Complete Publishing Cycle

   And here's a function that will publish my webpage from start to
   finish.

   #+BEGIN_SRC emacs-lisp
    (defun loomcom-publish ()
      "Publish my website."
      (interactive)
      (loomcom-publish-local)
      (loomcom-rsync-www))
   #+END_SRC

** Helper Function: Build a Preview for a Blog Page

   When I publish a post to my blog, I want the ability to publish a
   summary of the post to the main blog index page, followed by a
   /"Read More..."/ link that will take you to the full article.

   This helper function builds the preview string by returning
   anything in the post up to the first line that reads
   =#+BEGIN_more=.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom--get-preview (filename)
       "Get a preview string for a file.
     This function returns a list, '(<needs-more> <preview-string>),
     where <needs-more> is nil or non-nil, and indicates whether
     a \"Read More →\" link is needed.

     FILENAME The file to get a preview for."
       (with-temp-buffer
         (insert-file-contents (concat loomcom-blog-org-dir filename))
         (goto-char (point-min))
         (let ((content-start (or
                               ;; Look for the first non-keyword line
                               (and (re-search-forward "^[^#]" nil t)
                                    (match-beginning 0))
                               ;; Failing that, assume we're malformed and
                               ;; have no content
                               (buffer-size)))
               (marker (or
                        (and (re-search-forward "^#\\+BEGIN_more$" nil t)
                             (match-beginning 0))
                        (buffer-size))))
           ;; Return a pair of '(needs-more preview-string)
           (list (not (= marker (buffer-size)))
                 (buffer-substring content-start marker)))))
   #+END_src

** Helper Function: Insert A Page Header

   #+BEGIN_SRC emacs-lisp

     (defun loomcom--header (_)
       "Insert the header of the page."
       (with-temp-buffer
         (insert-file-contents loomcom-header-file)
         (buffer-string)))

   #+END_SRC

** Building a Sitemap for a Group of Pages

   My blog uses a paginated index, which is actually not supported by default
   in =org-publish=, so I do a lot of work to tweak it here.

   The first thing I do is define a function that will return a sitemap for a
   single page.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom--sitemap-for-group (title previous-page next-page list)
       "Generate the sitemap for one group of pages.

     TITLE  The title of the page
     PREVIOUS-PAGE  The previous index page to link to.
     NEXT-PAGE  The next index page to link to.
     LIST  The group of pages."
       (let ((previous-link (if previous-page
                                (format "[[%s][← Previous Page]]" previous-page)
                              ""))
             (next-link (if next-page
                            (format "[[%s][Next Page →]]" next-page)
                          "")))
         (concat "#+TITLE: " title "\n\n"
                 "#+BEGIN_pagination\n"
                 (format "- %s\n" previous-link)
                 (format "- %s\n" next-link)
                 "#+END_pagination\n\n"
                 (string-join (mapcar #'car (cdr list)) "\n\n"))))
   #+END_SRC

   Next, a function that will return a single entry in the sitemap.
   This is the actual entry that shows up on the index page!

   #+BEGIN_SRC emacs-lisp
     (defun loomcom--sitemap-entry (entry project)
       "Sitemap (Blog Main Page) Entry Formatter.

     ENTRY  The sitemap entry to format.
     PROJECT  The project structure."
       (when (not (directory-name-p entry))
         (format (string-join
                  '("* [[file:%s][%s]]\n"
                    "  :PROPERTIES:\n"
                    "  :PUBDATE: %s\n"
                    "  :END:\n"
                    "#+BEGIN_published\n"
                    "%s\n"
                    "#+END_published\n"
                    "%s"))
                 entry
                 (org-publish-find-title entry project)
                 (format-time-string (cdr org-time-stamp-formats) (org-publish-find-date entry project))
                 (format-time-string "%A, %B %_d %Y at %l:%M %p %Z" (org-publish-find-date entry project))
                 (let* ((preview (loomcom--get-preview entry))
                        (needs-more (car preview))
                        (preview-text (cadr preview)))
                   (if needs-more
                       (format
                        (concat
                         "%s\n\n"
                         "#+BEGIN_morelink\n"
                         "[[file:%s][Read More →]]\n"
                         "#+END_morelink\n")
                        preview-text entry)
                     (format "%s" preview-text))))))

   #+END_SRC

   Then we define a function that will take a subset of all the blog
   posts that are to be published, and turn them into a list.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom--sitemap-files-to-lisp (files project)
       "Convert a group of entries into a list.

     FILES  The group of entries to list-ify.
     PROJECT  The project structure."
       (let ((root (expand-file-name
                    (file-name-as-directory
                     (org-publish-property :base-directory project)))))
         (cons 'unordered
               (mapcar
                (lambda (f)
                  (list (loomcom--sitemap-entry (file-relative-name f root) project)))
                files))))
   #+END_SRC

   And here is the function that takes the entire set of articles to
   be published, and turns them into groups of =n= elements.

   #+BEGIN_SRC emacs-lisp
     (defun loomcom--group (source n)
       "Group a list by 'n' elements.

     SOURCE  The list.
     N  The number to group the list by."
       (if (not (endp (nthcdr n source)))
           (cons (subseq source 0 n)
                 (loomcom--group (nthcdr n source) n))
         (list source)))
   #+END_SRC

   Next, there's a helper function to find the date of an entry.  This
   mainly exists to help performance, because the sorting algorithm
   used to sort all the blog entries is very expensive and gets called
   n^2 times. Without this little helper and date cache, things would
   be a lot slower.

   #+BEGIN_SRC emacs-lisp
     ;;
     ;; We keep a local cache of filename to date. This speeds up
     ;; publishing tremendously, because org-publish-find-date is very
     ;; expensive, and the sorting predicate we use calls it n^2 times.
     ;;
     (setq loomcom-sitemap-file-dates (make-hash-table))

     (defun loomcom--find-date (file-name project)
       "Find the date for a file and cache it.

     FILE-NAME  The file in which to find a date.
     PROJECT  The project structure."
       (let ((maybe-date (gethash file-name loomcom-sitemap-file-dates nil)))
         (if maybe-date
             maybe-date
           (let ((new-date (org-publish-find-date file-name project)))
             (puthash file-name new-date loomcom-sitemap-file-dates)
             new-date))))
   #+END_SRC

   Then, the meat of the matter. This is a complete rewrite of the
   default =org-publish-sitemap= function that comes built into Org Mode.
   It redefines the behavior to add support for publishing a multi-page
   sitemap.

   #+BEGIN_SRC emacs-lisp
     ;; Un-define the original version of 'org-publish-sitemap'
     (fmakunbound 'org-publish-sitemap)

     ;; Define our own version.
     (defun org-publish-sitemap (project &optional sitemap-filename)
       "Publish the blog.

     This is actually a heavily modified and customized version of the
     function by the same name in ox-publish.el.  It allows the
     generation of a sitemap with multiple pages.

     PROJECT  The project structure.
     SITEMAP-FILENAME  The filename to use as the default index."
       (let* ((base (file-name-sans-extension (or sitemap-filename "index.org")))
              (root (file-name-as-directory (expand-file-name
                                             (concat loomcom-org-dir "blog/"))))
              (title (or (org-publish-property :sitemap-title project)
                         (concat "Sitemap for project " (car project))))
              (sort-predicate
               (lambda (a b)
                 (let* ((adate (loomcom--find-date a project))
                        (bdate (loomcom--find-date b project))
                        (A (+ (lsh (car adate) 16) (cadr adate)))
                        (B (+ (lsh (car bdate) 16) (cadr bdate))))
                   (>= A B))))
              (file-filter (lambda (f) (not (string-match (format "%s.*\\.org" base) f))))
              (files (seq-filter file-filter (org-publish-get-base-files project))))
         (message (format "Generating blog indexes for %s" title))
         (let* ((pages (sort files sort-predicate))
                (page-groups (loomcom--group pages loomcom-posts-per-page))
                (page-number 0))
           (dolist (group page-groups page-number)
             (let ((fname (if (eq 0 page-number)
                              (concat root (format "%s.org" base))
                            (concat root (format "%s_%d.org" base page-number))))
                   (previous-page (cond ((eq 0 page-number) nil)
                                        ((eq 1 page-number) (concat root (format "%s.org" base)))
                                        (t (concat root (format "%s_%d.org" base (- page-number 1))))))
                   (next-page (if (eq (- (length page-groups) 1) page-number)
                                  nil
                                (concat root (format "%s_%d.org" base (+ page-number 1))))))
               (setq page-number (+ 1 page-number))
               (with-temp-file fname
                 (insert
                  (loomcom--sitemap-for-group
                   title
                   previous-page
                   next-page
                   (loomcom--sitemap-files-to-lisp group project)))))))))
   #+END_SRC

   And finally, at long last, the actual configuration for Org Publish
   that defines the project.

   #+BEGIN_SRC emacs-lisp
     (setq org-publish-timestamp-directory (concat loomcom-project-dir "cache/"))
     (setq org-publish-project-alist
           `(("loomcom"
              :components ("blog" "pages" "res" "images"))

             ("blog"
              :base-directory ,loomcom-blog-org-dir
              :base-extension "org"
              :publishing-directory ,loomcom-blog-www-dir
              :publishing-function org-html-publish-to-html
              :with-author t
              :author "Seth Morabito"
              :email "web@loomcom.com"
              :with-creator nil
              :with-date t
              :section-numbers nil
              :with-title t
              :with-toc nil
              :with-drawers t
              :with-sub-superscript nil
              :html-doctype "html5"
              :html-link-home "https://loomcom.com/"
              :html-link-use-abs-url t
              :html-head ,loomcom-head
              :html-head-extra nil
              :html-head-include-default-style nil
              :html-head-include-scripts nil
              :html-viewport nil
              :html-link-up ""
              :html-link-home ""
              :html-preamble loomcom--header
              :html-postamble ,loomcom-footer
              :auto-sitemap t
              :sitemap-filename "index.org"
              :sitemap-title "Seth Morabito ∴ A Weblog"
              :sitemap-sort-files anti-chronologically)

             ("pages"
              :base-directory ,loomcom-org-dir
              :base-extension "org"
              :exclude ".*blog/.*"
              :publishing-directory ,loomcom-www-dir
              :publishing-function org-html-publish-to-html
              :section-numbers nil
              :recursive t
              :with-title t
              :with-toc nil
              :with-drawers t
              :with-sub-superscript nil
              :with-author t
              :author "Seth Morabito"
              :email "web@loomcom.com"
              :with-creator nil
              :with-date t
              :html-link-home "/"
              :html-head nil
              :html-doctype "html5"
              :html-head ,loomcom-head
              :html-head-extra nil
              :html-head-include-default-style nil
              :html-head-include-scripts nil
              :html-link-up ""
              :html-link-home ""
              :html-preamble loomcom--header
              :html-postamble ,loomcom-footer
              :html-viewport nil)

             ("res"
              :base-directory ,loomcom-org-dir
              :base-extension "css\\|js\\|woff2\\|woff\\|ttf"
              :recursive t
              :publishing-directory ,loomcom-www-dir
              :publishing-function org-publish-attachment)

             ("images"
              :base-directory ,loomcom-org-dir
              :base-extension "png\\|jpg\\|gif\\|pdf"
              :recursive t
              :publishing-directory ,loomcom-www-dir
              :publishing-function org-publish-attachment)))
   #+END_SRC

* Frame Placement

  Define a helper function that will center the frame on its display.

  #+BEGIN_SRC emacs-lisp
    (defun center-frame-in-display ()
      (interactive)
      (let* ((col-width (/ (frame-pixel-width) (frame-width)))
         (row-height (/ (frame-pixel-height) (frame-height)))
         (half-width (* (/ (frame-width) 2) col-width))
         (half-height (* (/ (frame-height) 2) row-height))
         (center-x (/ (display-pixel-width) 2))
         (center-y (/ (display-pixel-height) 2)))
    (set-frame-position
     (selected-frame)
     (- center-x half-width)
     (- center-y half-height))))
  #+END_SRC

  Then, resize and center the frame.

  #+BEGIN_SRC emacs-lisp
    (set-frame-width (selected-frame) 98)
    (set-frame-height (selected-frame) 56)
    (center-frame-in-display)
  #+END_SRC
